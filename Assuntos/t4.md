## Trabalho Final

Implemente um programa para jogar algo parecido com o jogo [threes](http://play.threesgame.com/).

O jogo é jogado em um tabuleiro contendo uma matriz de 4x4 posições, algumas delas preenchidas por cartas com números e outras vazias.
O objetivo é combinar as cartas para conseguir números maiores.
O jogo evolui em uma sequência de jogadas do jogador; em cada jogada, ele deve movimentar cartas, potencialmente combinando-as, e uma nova carta é colocada no tabuleiro.
Quando não houver mais movimento possível, o jogo termina e é calculada a pontuação, de acordo com as combinações que o jogador conseguiu realizar.

### Movimentos

Para movimentar as cartas, o jogador escolhe uma direção (para cima, para baixo, para a direita ou para a esquerda).
Todas as cartas que puderem se mover na direção escolhida são automaticamente movidas pelo programa. Caso nenhuma das cartas no tabuleiro puder se mover na direção escolhida, a jogada é inválida.
Uma carta se move na direção escolhida, sempre para a posição vizinha, não existe movimento de mais de uma posição.
O movimento pode ser analisado uma carta por vez.
Para facilitar a explicação vamos consider um movimento para a direita, nas demais direções o movimento é equivalente.
Nesse caso, cada carta só poderá se mover para a posição que está logo à sua direita.
Uma carta não poderá mudar de linha, então pode-se analisar o movimento em cada linha independentemente das demais.
A carta na posição mais à direita da linha (caso exista carta nessa posição) não pode se movimentar, porque não existe uma posição à sua direita. 
A carta à esquerda dela (na terceira posição da linha), e depois cada uma das demais, poderá se mover em dois casos:
se a posição à sua direita estiver livre ou se o seu valor puder ser combinado com o valor da carta na posição à sua direita. Existem dois tipos de combinações possíveis: uma carta com o valor 1 combina com uma carta com o valor 2 (ou vice-versa) produzindo uma carta com o valor 3. Uma carta com valor superior a 2 combina com uma carta de mesmo valor, produzindo uma carta com o dobro desse valor.
Somente valores produzidos a partir de cartas 1 e 2 são permitidos (somente podem existir cartas com valores 1, 2, 3, 6, 12, 24, 48 etc - exceto 1 e 2, são todos *3\*2<sup>n</sup>*, com *n* entre 0 e 11).

### Geração de cartas

Após cada movimentação, o jogo deve colocar uma nova carta no tabuleiro.
Essa carta deve ser colocada em posição contrária ao movimento realizado (se o movimento foi para a direita, a carta deverá aparecer na coluna mais à esquerda, se o movimento for para cima, deve aparecer na linha mais abaixo etc).
A carta deve aparecer em uma das linhas (ou colunas se o movimento for vertical) onde aconteceu movimento, escolhida aleatoriamente caso tenha havido movimento em mais de uma.

O algoritmo de escolha da próxima carta, segundo [kamikaze28](https://toucharcade.com/community/threads/threes-by-sirvo-llc.218248/page-27), é o seguinte:
- existem duas possibilidades de distribuição de cartas: as "normais" (cartas azuis, vermelhas ou brancas, de valor 1, 2 ou 3 respectivamente) e as "bônus" (cartas brancas de valor superior a 3);
- só existem cartas "bônus" depois do momento em que for formada uma carta com o valor 48;
- as cartas "normais" saem de um "baralho" de 12 cartas, que contém 4 cartas de cada tipo. Cada vez que todas as cartas de um "baralho" são distribuídas, um novo é criado e embaralhado;
- depois que as cartas "bônus" puderem aparecer, a cada carta distribuída existe uma chance de 1/21 de ela ser uma carta "bônus" e 20/21 de ser uma carta "normal";
- uma carta "bônus" tem um valor entre 6 e 1/8 do valor da maior carta que já apareceu no jogo (sempre obedecendo ao valor *3\*2<sup>n</sup>*). O valor específico é escolhido aleatoriamente entre os possíveis, com mesma probabilidade.

### Pontuação

Quando terminar o jogo (não houver mais movimento possível), o jogo calcula e apresenta o total de pontos do jogador, correspondente à soma dos pontos das cartas que no tabuleiro. As cartas com valor 1 e 2 não valem ponto; uma carta com o valor *3\*2<sup>n</sup>* vale *3<sup>n+1</sup>* pontos.

### Início do jogo

O tabuleiro é preenchido com 9 cartas, obtidas do primeiro "baralho", colocadas em posições aleatórias do tabuleiro.

### Como é uma jogada

O laço principal do jogo faz o seguinte:
- desenha o tabuleiro,
- verifica se tem jogada possível,
- informa o tipo da próxima carta (azul, vermelho, branco ou bônus),
- espera a jogada do jogador,
- verifica se a jogada é válida,
- move as cartas no tabuleiro de acordo com a jogada,
- posiciona a próxima carta no tabuleiro.

### Brinde

Uma função para calcular a próxima carta!
A parte ruim é que sua implementação **deve** usar a função abaixo, sem modificação, para todos os sorteios de uma nova carta. Você deve implementar as funções e tipos de dados que ela usa, e inicializar/atualizar os dados para que ela funcione corretamente.
```c
int proxima_carta(threes *jogo)
{
  if (jogo->n_da_maior_carta >= 4 && aleatorio_entre(1, 21) == 21) {
    // carta bônus
    return 3*pow(2, aleatorio_entre(1, jogo->n_da_maior_carta-3));
  }
  // carta normal
  if (jogo->proximo_do_baralho == 0) {
    embaralha_vetor(12, jogo->baralho);
  }
  int carta = jogo->baralho[jogo->proximo_do_baralho];
  jogo->proximo_do_baralho++;
  if (jogo->proximo_do_baralho >= 12) {
    jogo->proximo_do_baralho = 0;
  }
  return carta;
}
}
```
