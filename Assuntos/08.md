## Comandos de repetição

Muitas vezes, precisamos que nosso programa repita certo número de comandos.
As linguagens de programação oferecem várias formas de se expressar repetição.
A linguagem C possui 3 desses comandos, `for`, `while` e `do .. while`.

O comando de repetição `for` da linguagem C tem o seguinte formato:
```c
for (inicialização; condição; incremento) {
  comandos
}
```
O funcionamento dele é o seguinte: inicialmente é executada a `inicialização`.
Então é avaliada a `condição`. Se a condição for falsa, o comando `for` termina.
Se a condição for verdadeira, os `comandos` são executados.
Após a execução dos comandos, é executado o `incremento` e volta a repetir a partir da avaliação da condição.

Tipicamente o comando `for` é usado quando se conhece o número de repetições que se quer executar. 
A `inicialização`, `condição` e `incremento` são usados para realizar esse controle, usando uma variável para auxiliar.
Por exemplo, para executar o comando printf abaixo 20 vezes, o código mais comum é:
```c
int i;
for (i=0; i<20; i = i+1) {
  printf(".");
}
```
A variável `i` vai ser inicializada em 0; a cada vez, se ela for menor que 20 o print será executado; após cada execução, o valor da variável será incrementado.
Se diz nesse caso que o comando `for` está sendo controlado pela variável `i`, chamada variável de controle. Esse caso é tão comum que pode-se declarar a variável de controle dentro do próprio comando `for`, e ela é destruída quando o comando `for` acaba:
```c
for (int i=0; i<20; i = i+1) {
  printf(".");
}
// aqui a variável i não existe mais
```
Um comando de repetição é por vezes chamado de *laço de repetição*.
É bastante comum se precisar saber em qual das repetições se está.
Para isso, acessa-se o valor da variável de controle nos comandos controlados pelo `for`.
No exemplo acima, na primeira execução o valor de `i` é zero, na segunda é 1, na vigésima é 19. Por exemplo, pode-se usar esse valor para imprimir:
```c
for (int i=0; i<20; i = i+1) {
  printf("%d ", i*10);
}
```
Apesar de permitido, não é recomendável alterar o valor da variável de controle dentro do laço.

Quaisquer dos 3 componentes do `for` dentro dos parênteses pode ser omitido. Se o primeiro for omitido, não será executado nada antes de iniciar a repetição; se o segundo for omitido, será considerado sempre como `true` e a repetição deverá ser interrompida de outra forma; se o terceiro for omitido, não será executado nada após a execução dos comandos controlados. Os `;` não podem ser omitidos.
O comando `for (;;)` é uma forma de se representar um laço infinito.

### Comandos *break* e *continue*

Os comandos de repetição da linguagem tomam a decisão de repetir ou não a execução dos comandos que controlam aanlisando uma expressão lógica.
No comando `for`, essa expressão é analisada logo antes de executar os comandos controlados, e o teste só será realizado novamente antes da execução seguinte.
Por vezes, porém, a informação sobre essa execução só está disponível no meio da execução dos comandos controlados, o que pode deixar o código um pouco mais complicado do que o necessário.
Para esses casos, existem dois comandos, que só podem ser usados dentro de laços, e que ajudam a melhor controlá-los.
Esses comandos interrompem a execução do laço, e estão geralmente colocados dentro de comandos de seleção (não faz muito sentido interromper a execução do laço de forma incondicional).

O comando `break` interrompe a execução do comando de repetição onde ele se encontra (o primeiro comando a ser executado após o `break` é o comando que está depois do `for`).
Um exemplo típico de uso do `break` é a identificação de um dado que representa o final da entrada, estando a leitura do dado no interior da repetição.

O comando `continue` interrompe a execução do laço corrente, causando a execução do próximo laço (depois do `continue`, será executado o *incremento*, e calculado o valor da expressão de controle do `for`, para verificar se a repetição continua ou não).
Um exemplo de uso do `continue` é a identificação de um dado que deva ser ignorado entre os dados que estão sendo considerados para processamento.

No exemplo abaixo, devem ser processados somente os números pares, e os dados terminam com um valor negativo.
```c
  for (;;) {
    d = consegue_proximo_dado();
    if (d < 0) break;
    if (!par(d)) continue;
    processa_dado(d);
  }
```
